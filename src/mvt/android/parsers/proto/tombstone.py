# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: tombstone.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import Dict, List

import betterproto


class Architecture(betterproto.Enum):
    ARM32 = 0
    ARM64 = 1
    X86 = 2
    X86_64 = 3
    RISCV64 = 4
    NONE = 5


class MemoryErrorTool(betterproto.Enum):
    GWP_ASAN = 0
    SCUDO = 1


class MemoryErrorType(betterproto.Enum):
    UNKNOWN = 0
    USE_AFTER_FREE = 1
    DOUBLE_FREE = 2
    INVALID_FREE = 3
    BUFFER_OVERFLOW = 4
    BUFFER_UNDERFLOW = 5


@dataclass
class CrashDetail(betterproto.Message):
    """
    NOTE TO OEMS: If you add custom fields to this proto, do not use numbers in
    the reserved range.
    """

    name: bytes = betterproto.bytes_field(1)
    data: bytes = betterproto.bytes_field(2)


@dataclass
class StackHistoryBufferEntry(betterproto.Message):
    addr: "BacktraceFrame" = betterproto.message_field(1)
    fp: int = betterproto.uint64_field(2)
    tag: int = betterproto.uint64_field(3)


@dataclass
class StackHistoryBuffer(betterproto.Message):
    tid: int = betterproto.uint64_field(1)
    entries: List["StackHistoryBufferEntry"] = betterproto.message_field(2)


@dataclass
class Tombstone(betterproto.Message):
    arch: "Architecture" = betterproto.enum_field(1)
    guest_arch: "Architecture" = betterproto.enum_field(24)
    build_fingerprint: str = betterproto.string_field(2)
    revision: str = betterproto.string_field(3)
    timestamp: str = betterproto.string_field(4)
    pid: int = betterproto.uint32_field(5)
    tid: int = betterproto.uint32_field(6)
    uid: int = betterproto.uint32_field(7)
    selinux_label: str = betterproto.string_field(8)
    command_line: List[str] = betterproto.string_field(9)
    # Process uptime in seconds.
    process_uptime: int = betterproto.uint32_field(20)
    signal_info: "Signal" = betterproto.message_field(10)
    abort_message: str = betterproto.string_field(14)
    crash_details: List["CrashDetail"] = betterproto.message_field(21)
    causes: List["Cause"] = betterproto.message_field(15)
    threads: Dict[int, "Thread"] = betterproto.map_field(
        16, betterproto.TYPE_UINT32, betterproto.TYPE_MESSAGE
    )
    guest_threads: Dict[int, "Thread"] = betterproto.map_field(
        25, betterproto.TYPE_UINT32, betterproto.TYPE_MESSAGE
    )
    memory_mappings: List["MemoryMapping"] = betterproto.message_field(17)
    log_buffers: List["LogBuffer"] = betterproto.message_field(18)
    open_fds: List["FD"] = betterproto.message_field(19)
    page_size: int = betterproto.uint32_field(22)
    has_been_16kb_mode: bool = betterproto.bool_field(23)
    stack_history_buffer: "StackHistoryBuffer" = betterproto.message_field(26)


@dataclass
class Signal(betterproto.Message):
    number: int = betterproto.int32_field(1)
    name: str = betterproto.string_field(2)
    code: int = betterproto.int32_field(3)
    code_name: str = betterproto.string_field(4)
    has_sender: bool = betterproto.bool_field(5)
    sender_uid: int = betterproto.int32_field(6)
    sender_pid: int = betterproto.int32_field(7)
    has_fault_address: bool = betterproto.bool_field(8)
    fault_address: int = betterproto.uint64_field(9)
    # Note, may or may not contain the dump of the actual memory contents.
    # Currently, on arm64, we only include metadata, and not the contents.
    fault_adjacent_metadata: "MemoryDump" = betterproto.message_field(10)


@dataclass
class HeapObject(betterproto.Message):
    address: int = betterproto.uint64_field(1)
    size: int = betterproto.uint64_field(2)
    allocation_tid: int = betterproto.uint64_field(3)
    allocation_backtrace: List["BacktraceFrame"] = betterproto.message_field(4)
    deallocation_tid: int = betterproto.uint64_field(5)
    deallocation_backtrace: List["BacktraceFrame"] = betterproto.message_field(6)


@dataclass
class MemoryError(betterproto.Message):
    tool: "MemoryErrorTool" = betterproto.enum_field(1)
    type: "MemoryErrorType" = betterproto.enum_field(2)
    heap: "HeapObject" = betterproto.message_field(3, group="location")


@dataclass
class Cause(betterproto.Message):
    human_readable: str = betterproto.string_field(1)
    memory_error: "MemoryError" = betterproto.message_field(2, group="details")


@dataclass
class Register(betterproto.Message):
    name: str = betterproto.string_field(1)
    u64: int = betterproto.uint64_field(2)


@dataclass
class Thread(betterproto.Message):
    id: int = betterproto.int32_field(1)
    name: str = betterproto.string_field(2)
    registers: List["Register"] = betterproto.message_field(3)
    backtrace_note: List[str] = betterproto.string_field(7)
    unreadable_elf_files: List[str] = betterproto.string_field(9)
    current_backtrace: List["BacktraceFrame"] = betterproto.message_field(4)
    memory_dump: List["MemoryDump"] = betterproto.message_field(5)
    tagged_addr_ctrl: int = betterproto.int64_field(6)
    pac_enabled_keys: int = betterproto.int64_field(8)


@dataclass
class BacktraceFrame(betterproto.Message):
    rel_pc: int = betterproto.uint64_field(1)
    pc: int = betterproto.uint64_field(2)
    sp: int = betterproto.uint64_field(3)
    function_name: str = betterproto.string_field(4)
    function_offset: int = betterproto.uint64_field(5)
    file_name: str = betterproto.string_field(6)
    file_map_offset: int = betterproto.uint64_field(7)
    build_id: str = betterproto.string_field(8)


@dataclass
class ArmMTEMetadata(betterproto.Message):
    # One memory tag per granule (e.g. every 16 bytes) of regular memory.
    memory_tags: bytes = betterproto.bytes_field(1)


@dataclass
class MemoryDump(betterproto.Message):
    register_name: str = betterproto.string_field(1)
    mapping_name: str = betterproto.string_field(2)
    begin_address: int = betterproto.uint64_field(3)
    memory: bytes = betterproto.bytes_field(4)
    arm_mte_metadata: "ArmMTEMetadata" = betterproto.message_field(6, group="metadata")


@dataclass
class MemoryMapping(betterproto.Message):
    begin_address: int = betterproto.uint64_field(1)
    end_address: int = betterproto.uint64_field(2)
    offset: int = betterproto.uint64_field(3)
    read: bool = betterproto.bool_field(4)
    write: bool = betterproto.bool_field(5)
    execute: bool = betterproto.bool_field(6)
    mapping_name: str = betterproto.string_field(7)
    build_id: str = betterproto.string_field(8)
    load_bias: int = betterproto.uint64_field(9)


@dataclass
class FD(betterproto.Message):
    fd: int = betterproto.int32_field(1)
    path: str = betterproto.string_field(2)
    owner: str = betterproto.string_field(3)
    tag: int = betterproto.uint64_field(4)


@dataclass
class LogBuffer(betterproto.Message):
    name: str = betterproto.string_field(1)
    logs: List["LogMessage"] = betterproto.message_field(2)


@dataclass
class LogMessage(betterproto.Message):
    timestamp: str = betterproto.string_field(1)
    pid: int = betterproto.uint32_field(2)
    tid: int = betterproto.uint32_field(3)
    priority: int = betterproto.uint32_field(4)
    tag: str = betterproto.string_field(5)
    message: str = betterproto.string_field(6)
